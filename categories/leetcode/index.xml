<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on SYSUcarey</title>
    <link>https://sysucarey.github.io/categories/leetcode/</link>
    <description>Recent content in Leetcode on SYSUcarey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Nov 2018 22:50:53 +0800</lastBuildDate>
    
	<atom:link href="https://sysucarey.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 54 Spiral Matrix</title>
      <link>https://sysucarey.github.io/leetcode-54-spiral-matrix/</link>
      <pubDate>Sun, 18 Nov 2018 22:50:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode-54-spiral-matrix/</guid>
      <description>Table of Contents  题目 思考 解法  Solution code(c++)   Created by gh-md-toc
题目  链接：  Leetcode 54 Spiral Matrix
 难度：  Difficulty: Medium
Acceptance: 28.7%
 概述：  Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
Example 1:
 Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5]  Example 2:</description>
    </item>
    
    <item>
      <title>Leetcode84 Largest Rectangle in Histogram</title>
      <link>https://sysucarey.github.io/leetcode84-largest-rectangle-in-histogram/</link>
      <pubDate>Sun, 11 Nov 2018 20:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode84-largest-rectangle-in-histogram/</guid>
      <description>题目  链接：  Leetcode84 Largest Rectangle in Histogram
 概述：
 Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.   Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.</description>
    </item>
    
    <item>
      <title>Leetcode18 4Sum</title>
      <link>https://sysucarey.github.io/leetcode18-4sum/</link>
      <pubDate>Sun, 04 Nov 2018 23:33:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode18-4sum/</guid>
      <description>题目  链接：  Leetcode18 4Sum
 概述：  Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b+ c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
 Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title>Leetcode581 Shortest Unsorted Continuous Subarray</title>
      <link>https://sysucarey.github.io/leetcode581-shortest-unsorted-continuous-subarray/</link>
      <pubDate>Fri, 26 Oct 2018 14:49:15 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode581-shortest-unsorted-continuous-subarray/</guid>
      <description>题目  链接：  Leetcode581 Shortest Unsorted Continuous Subarray
 概述：  Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.
You need to find the shortest such subarray and output its length.
Example 1:
 Input: [2, 6, 4, 8, 10, 9, 15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</description>
    </item>
    
    <item>
      <title>Leetcode31 Next Permutation</title>
      <link>https://sysucarey.github.io/leetcode31-next-permutation/</link>
      <pubDate>Thu, 25 Oct 2018 20:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode31-next-permutation/</guid>
      <description>题目  链接：  Leetcode31 Next Permutation
 概述：  Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place and use only constant extra memory.
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</description>
    </item>
    
    <item>
      <title>Leetcode57 Insert Interval</title>
      <link>https://sysucarey.github.io/leetcode57-insert-interval/</link>
      <pubDate>Thu, 18 Oct 2018 22:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode57-insert-interval/</guid>
      <description>题目  链接：  Leetcode57 Insert Interval
 概述：  Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
 Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]  Example 2:
 Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</description>
    </item>
    
    <item>
      <title>Leetcode56 Merge Intervals</title>
      <link>https://sysucarey.github.io/leetcode56-merge-intervals/</link>
      <pubDate>Sun, 14 Oct 2018 10:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode56-merge-intervals/</guid>
      <description>题目  链接：  Leetcode56 Merge Intervals
 概述：  Given a collection of intervals, merge all overlapping intervals.
Example 1:
 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2:
 Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considerred overlapping.  思考 分析一：
 合并区间的操作在我们思考中是比较简单的，首先的第一步应该是排序操作，将区间的最小值为Key进行从小到大排序。然后就是从数组第一个区间开始判断到最后一个区间。具体对于自定义结构体的sort数组操作，类内和类外的区别等细节，参考博客。 如果前一个区间的最大值比后一个区间的最小值小，那么没有区间合并操作；如果前一个区间的最大值比后一个区间的最小值大，但比最大值小，那么区间合并成[前一个区间的最小值，后一个区间的最大值]；如果前一个区间的最大值比后一个区间的最大值都大，相当于后一个区间没有用，直接删去。 这样我们就可以得到Solution1，排序复杂度为O(nlogn)，一个for循环，O(n)。一开始我以为算法复杂度是O(nlogn)，但后来我发现错了，因为在数组中删去一个元素erase操作的复杂度为O(n)，所以总复杂度应该是O(n^2)，这样我们非但没有降低到我们想要的复杂度，而且还调用了很多erase操作，还有一个sort操作，还有数组的克隆操作，这样还是蛮慢的，可以预见到算法还有优化的空间。  分析二：
 我们考虑优化分析一，造成Solution1中复杂度升到O(n^2)的原因在于for循环中进行了删除元素的操作。那么我们考虑是否可以先判断完，再添加进answer数组，而不是一开始先复制后删除。 基于这样的考虑，我们可以先把intervals数组排序，然后先比较完是否需要进行合并区间，如果是需要合并的话，因为intervals已经基于区间start值排序了，那么也就是说要添加的新区间的start一定比answer中最后一个元素区间的start值要大，那么我们只需要修改answer中最后一个元素区间的end值；不需要合并的话，就直接把新区间添加进answer数组中即可。 这样我们就可以得到Solution2，复杂度为O(nlogn)。  解法 Solution1：</description>
    </item>
    
    <item>
      <title>Leetcode74 Search a 2D Matrix</title>
      <link>https://sysucarey.github.io/leetcode74-search-a-2d-matrix/</link>
      <pubDate>Thu, 04 Oct 2018 21:22:32 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode74-search-a-2d-matrix/</guid>
      <description>题目论述  链接：  Leetcode74 Search a 2D Matrix
 概述：  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1:
 Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Leetcode119 Pascal&#39;s Triangle II</title>
      <link>https://sysucarey.github.io/leetcode119-pascals-triangle-ii/</link>
      <pubDate>Tue, 02 Oct 2018 23:20:50 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode119-pascals-triangle-ii/</guid>
      <description>题目论述  链接：  Leetcode119 Pascal&amp;rsquo;s Triangle II
 概述：  Given a non-negative index k where k ≤ 33, return the k th index row of the Pascal&amp;rsquo;s triangle.
Note that the row index starts from 0.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example:
 Input: 3 Output: [1,3,3,1]  Follow up:
Could you optimize your algorithm to use only O(k) extra space?</description>
    </item>
    
    <item>
      <title>Leetcode15 3Sum</title>
      <link>https://sysucarey.github.io/leetcode15-3sum/</link>
      <pubDate>Sun, 30 Sep 2018 22:25:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode15-3sum/</guid>
      <description>题目论述  链接：  Leetcode15 3Sum
 概述：  Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
 Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  思考分析 分析一：</description>
    </item>
    
  </channel>
</rss>