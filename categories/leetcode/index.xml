<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on SYSUcarey</title>
    <link>https://sysucarey.github.io/categories/leetcode/</link>
    <description>Recent content in Leetcode on SYSUcarey</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 14 Oct 2018 10:30:53 +0800</lastBuildDate>
    
	<atom:link href="https://sysucarey.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode56 Merge Intervals</title>
      <link>https://sysucarey.github.io/leetcode56-merge-intervals/</link>
      <pubDate>Sun, 14 Oct 2018 10:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode56-merge-intervals/</guid>
      <description>题目  链接：  Leetcode56 Merge Intervals
 概述：  Given a collection of intervals, merge all overlapping intervals.
Example 1:
 Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].  Example 2:
 Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considerred overlapping.  思考 分析一：
 合并区间的操作在我们思考中是比较简单的，首先的第一步应该是排序操作，将区间的最小值为Key进行从小到大排序。然后就是从数组第一个区间开始判断到最后一个区间。具体对于自定义结构体的sort数组操作，类内和类外的区别等细节，参考博客。 如果前一个区间的最大值比后一个区间的最小值小，那么没有区间合并操作；如果前一个区间的最大值比后一个区间的最小值大，但比最大值小，那么区间合并成[前一个区间的最小值，后一个区间的最大值]；如果前一个区间的最大值比后一个区间的最大值都大，相当于后一个区间没有用，直接删去。 这样我们就可以得到Solution1，排序复杂度为O(nlogn)，一个for循环，O(n)。一开始我以为算法复杂度是O(nlogn)，但后来我发现错了，因为在数组中删去一个元素erase操作的复杂度为O(n)，所以总复杂度应该是O(n^2)，这样我们非但没有降低到我们想要的复杂度，而且还调用了很多erase操作，还有一个sort操作，还有数组的克隆操作，这样还是蛮慢的，可以预见到算法还有优化的空间。  分析二：
 我们考虑优化分析一，造成Solution1中复杂度升到O(n^2)的原因在于for循环中进行了删除元素的操作。那么我们考虑是否可以先判断完，再添加进answer数组，而不是一开始先复制后删除。 基于这样的考虑，我们可以先把intervals数组排序，然后先比较完是否需要进行合并区间，如果是需要合并的话，因为intervals已经基于区间start值排序了，那么也就是说要添加的新区间的start一定比answer中最后一个元素区间的start值要大，那么我们只需要修改answer中最后一个元素区间的end值；不需要合并的话，就直接把新区间添加进answer数组中即可。 这样我们就可以得到Solution2，复杂度为O(nlogn)。  解法 Solution1：</description>
    </item>
    
    <item>
      <title>Leetcode18 4Sum</title>
      <link>https://sysucarey.github.io/leetcode18-4sum/</link>
      <pubDate>Sun, 07 Oct 2018 22:33:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode18-4sum/</guid>
      <description>题目  链接：  Leetcode18 4Sum
 概述：  Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b+ c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
 Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title>Leetcode74 Search a 2D Matrix</title>
      <link>https://sysucarey.github.io/leetcode74-search-a-2d-matrix/</link>
      <pubDate>Thu, 04 Oct 2018 21:22:32 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode74-search-a-2d-matrix/</guid>
      <description>题目论述  链接：  Leetcode74 Search a 2D Matrix
 概述：  Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1:
 Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true  Example 2:</description>
    </item>
    
    <item>
      <title>Leetcode119 Pascal&#39;s Triangle II</title>
      <link>https://sysucarey.github.io/leetcode119-pascals-triangle-ii/</link>
      <pubDate>Tue, 02 Oct 2018 23:20:50 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode119-pascals-triangle-ii/</guid>
      <description>题目论述  链接：  Leetcode119 Pascal&amp;rsquo;s Triangle II
 概述：  Given a non-negative index k where k ≤ 33, return the k th index row of the Pascal&amp;rsquo;s triangle.
Note that the row index starts from 0.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example:
 Input: 3 Output: [1,3,3,1]  Follow up:
Could you optimize your algorithm to use only O(k) extra space?</description>
    </item>
    
    <item>
      <title>Leetcode15 3Sum</title>
      <link>https://sysucarey.github.io/leetcode15-3sum/</link>
      <pubDate>Sun, 30 Sep 2018 22:25:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode15-3sum/</guid>
      <description>题目论述  链接：  Leetcode15 3Sum
 概述：  Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
 Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]  思考分析 分析一：</description>
    </item>
    
    <item>
      <title>Leetcode11: Container With Most Water</title>
      <link>https://sysucarey.github.io/leetcode11-container-with-most-water/</link>
      <pubDate>Sun, 23 Sep 2018 22:50:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode11-container-with-most-water/</guid>
      <description>题目论述  链接：Leetcode11: Container With Most Water
 概述：
  Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title>Leetcode4: Median of Two Sorted Arrays</title>
      <link>https://sysucarey.github.io/leetcode4-median-of-two-sorted-arrays/</link>
      <pubDate>Sun, 16 Sep 2018 23:50:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode4-median-of-two-sorted-arrays/</guid>
      <description>题目论述  链接：leetcode 4
 概述：
  There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1:
 nums1 = [1, 3] nums2 = [2] The median is 2.0  Example 2:
 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.</description>
    </item>
    
    <item>
      <title>Leetcode16: 3 Sum Closet</title>
      <link>https://sysucarey.github.io/leetcode16-3-sum-closet/</link>
      <pubDate>Sun, 09 Sep 2018 20:30:53 +0800</pubDate>
      
      <guid>https://sysucarey.github.io/leetcode16-3-sum-closet/</guid>
      <description>题目： Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</description>
    </item>
    
  </channel>
</rss>